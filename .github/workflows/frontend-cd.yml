name: Stage 3 - Frontend CD - Deploy to Staging

on:
  repository_dispatch:
    types: [backend_cd_succeeded]
  workflow_dispatch:
    inputs:
      aks_cluster_name:
        required: false
        default: ""
      aks_resource_group:
        required: false
        default: ""
      product_url:
        required: false
        default: ""
      order_url:
        required: false
        default: ""
      customer_url:
        required: false
        default: ""

jobs:
  deploy_frontend:
    runs-on: ubuntu-latest
    env:
      # frontend namespace (unique per run)
      NS: sit722-frontend-${{ github.run_id }}

      # fallback service names for discovery (if payload/manual not provided)
      PRODUCT_SVC: product-service
      ORDER_SVC: order-service
      CUSTOMER_SVC: customer-service

      PROD_PORT: "8001"
      ORD_PORT:  "8002"
      CUST_PORT: "8003"

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: AKS context
        run: |
          RG="${{ secrets.AKS_RESOURCE_GROUP }}"
          CL="${{ secrets.AKS_CLUSTER }}"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            [ -n "${{ inputs.aks_resource_group }}" ] && RG="${{ inputs.aks_resource_group }}"
            [ -n "${{ inputs.aks_cluster_name }}" ]    && CL="${{ inputs.aks_cluster_name }}"
          fi
          az aks get-credentials --resource-group "$RG" --name "$CL" --overwrite-existing

      - name: Ensure namespace
        run: |
          kubectl get ns "$NS" >/dev/null 2>&1 || kubectl create namespace "$NS"

      - name: Resolve backend endpoints (payload > manual > discovery)
        id: resolve
        shell: bash
        run: |
          set -euo pipefail
          trim_slash(){ printf "%s" "${1%/}"; }

          # 1) prefer repository_dispatch payload
          P_IN="${{ github.event.client_payload.product_url || '' }}"
          O_IN="${{ github.event.client_payload.order_url   || '' }}"
          C_IN="${{ github.event.client_payload.customer_url|| '' }}"

          # 2) manual overrides (workflow_dispatch inputs)
          [ -z "$P_IN" ] && P_IN="${{ inputs.product_url || '' }}"
          [ -z "$O_IN" ] && O_IN="${{ inputs.order_url   || '' }}"
          [ -z "$C_IN" ] && C_IN="${{ inputs.customer_url|| '' }}"

          if [[ -n "${P_IN}${O_IN}${C_IN}" ]]; then
            P_BASE="$(trim_slash "$P_IN")"
            O_BASE="$(trim_slash "$O_IN")"
            C_BASE="$(trim_slash "$C_IN")"
            # WRITE UNQUOTED VALUES (no surrounding quotes)
            echo "PRODUCT_URL=${P_BASE}"   >> "$GITHUB_ENV"
            echo "ORDER_URL=${O_BASE}"     >> "$GITHUB_ENV"
            echo "CUSTOMER_URL=${C_BASE}"  >> "$GITHUB_ENV"
            echo "::notice::Using provided backend roots: ${P_BASE} ${O_BASE} ${C_BASE}"
            exit 0
          fi

          # 3) fallback discovery across namespaces
          need_ns(){ kubectl get svc -A | awk -v n="$1" '$2==n{print $1; exit}'; }
          get_ep(){ kubectl get svc "$2" -n "$1" -o jsonpath='{.status.loadBalancer.ingress[0].ip}{.status.loadBalancer.ingress[0].hostname}'; }

          P_NS=$(need_ns "${PRODUCT_SVC}")   || { echo "::error::${PRODUCT_SVC} not found"; exit 1; }
          O_NS=$(need_ns "${ORDER_SVC}")     || { echo "::error::${ORDER_SVC} not found"; exit 1; }
          C_NS=$(need_ns "${CUSTOMER_SVC}")  || { echo "::error::${CUSTOMER_SVC} not found"; exit 1; }

          P_EP=""; O_EP=""; C_EP=""
          for i in $(seq 1 120); do
            P_EP=$(get_ep "$P_NS" "${PRODUCT_SVC}")   || true
            O_EP=$(get_ep "$O_NS" "${ORDER_SVC}")     || true
            C_EP=$(get_ep "$C_NS" "${CUSTOMER_SVC}")  || true
            if [[ -n "$P_EP" && -n "$O_EP" && -n "$C_EP" ]]; then break; fi
            echo "Waiting for backend LB endpoints... attempt $i"
            sleep 5
          done

          if [[ -z "$P_EP" || -z "$O_EP" || -z "$C_EP" ]]; then
            echo "::error::Timed out waiting for LoadBalancer endpoints"
            kubectl get svc -A -o wide || true
            exit 1
          fi

          # store plain root URLs (no extra quotes)
          echo "PRODUCT_URL=http://${P_EP}:${PROD_PORT}"   >> "$GITHUB_ENV"
          echo "ORDER_URL=http://${O_EP}:${ORD_PORT}"      >> "$GITHUB_ENV"
          echo "CUSTOMER_URL=http://${C_EP}:${CUST_PORT}"  >> "$GITHUB_ENV"

          echo "::notice::Resolved Product=${PRODUCT_URL:-}"
          echo "::notice::Resolved Order=${ORDER_URL:-}"
          echo "::notice::Resolved Customer=${CUSTOMER_URL:-}"

      - name: Inject API URLs into frontend/main.js and sanitize patterns
        shell: bash
        run: |
          set -euo pipefail

          # Ensure placeholders are inside JS quotes so sed produces valid string literals.
          sed -i 's|const PRODUCT_API_BASE_URL *= *.*|const PRODUCT_API_BASE_URL = "_PRODUCT_API_URL_";|' frontend/main.js || true
          sed -i 's|const ORDER_API_BASE_URL *= *.*|const ORDER_API_BASE_URL = "_ORDER_API_URL_";|' frontend/main.js || true
          sed -i 's|const CUSTOMER_API_BASE_URL *= *.*|const CUSTOMER_API_BASE_URL = "_CUSTOMER_API_BASE_URL_";|' frontend/main.js || true

          # Replace placeholders with the plain root URLs.
          sed -i "s|_PRODUCT_API_URL_|${PRODUCT_URL}|g"   frontend/main.js
          sed -i "s|_ORDER_API_URL_|${ORDER_URL}|g"       frontend/main.js
          sed -i "s|_CUSTOMER_API_URL_|${CUSTOMER_URL}|g" frontend/main.js

          # Conservative sanitization: prevent building relative paths under frontend host.
          sed -i "s|\${window.location.origin}/\${PRODUCT_API_BASE_URL}|\${PRODUCT_API_BASE_URL}|g" frontend/main.js || true
          sed -i "s|\${window.location.origin}/\${ORDER_API_BASE_URL}|\${ORDER_API_BASE_URL}|g" frontend/main.js || true
          sed -i "s|\${window.location.origin}/\${CUSTOMER_API_BASE_URL}|\${CUSTOMER_API_BASE_URL}|g" frontend.main.js || true || true

          sed -i "s|window.location.origin + '/' + PRODUCT_API_BASE_URL|PRODUCT_API_BASE_URL|g" frontend/main.js || true
          sed -i "s|window.location.origin + '/' + ORDER_API_BASE_URL|ORDER_API_BASE_URL|g" frontend/main.js || true
          sed -i "s|window.location.origin + '/' + CUSTOMER_API_BASE_URL|CUSTOMER_API_BASE_URL|g" frontend/main.js || true

          sed -i "s|fetch('/' + PRODUCT_API_BASE_URL|fetch(PRODUCT_API_BASE_URL|g" frontend/main.js || true
          sed -i "s|fetch('/' + ORDER_API_BASE_URL|fetch(ORDER_API_BASE_URL|g" frontend/main.js || true
          sed -i "s|fetch('/' + CUSTOMER_API_BASE_URL|fetch(CUSTOMER_API_BASE_URL|g" frontend/main.js || true

          echo "--- main.js preview (first 40 lines) ---"
          head -n 40 frontend/main.js

      - name: ACR login
        run: |
          REG="${{ secrets.ACR_LOGIN_SERVER }}"
          NAME="${REG##https://}"; NAME="${NAME%%/*}"; NAME="${NAME%%.azurecr.io}"
          az acr login --name "$NAME"

      - name: Build & push image
        run: |
          docker build -t ${{ secrets.ACR_LOGIN_SERVER }}/frontend:latest ./frontend
          docker push ${{ secrets.ACR_LOGIN_SERVER }}/frontend:latest

      - name: Deploy frontend
        run: |
          kubectl apply -n "$NS" -f k8s/frontend.yaml
          kubectl get deploy,svc,pod -n "$NS" -o wide || true

      - name: Wait for frontend LoadBalancer address
        run: |
          for i in $(seq 1 60); do
            FADDR=$(kubectl get svc frontend -n "$NS" -o jsonpath='{.status.loadBalancer.ingress[0].ip}{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)
            [ -n "$FADDR" ] && break
            echo "Waiting for frontend LB address... attempt $i"
            sleep 5
          done
          [ -n "$FADDR" ] || { echo "::error::Frontend address not assigned"; exit 1; }
          echo "::notice:: Frontend URL: http://$FADDR"
