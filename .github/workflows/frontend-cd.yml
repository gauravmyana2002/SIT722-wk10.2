name: Stage 3 - Frontend CD - Deploy to Staging

on:
  repository_dispatch:
    types: [backend_cd_succeeded]
  workflow_dispatch:
    inputs:
      aks_cluster_name:
        required: false
        default: ""
      aks_resource_group:
        required: false
        default: ""
      product_url:
        required: false
        default: ""
      order_url:
        required: false
        default: ""
      customer_url:
        required: false
        default: ""

jobs:
  deploy_frontend:
    runs-on: ubuntu-latest
    env:
      # Frontend namespace
      NS: sit722-frontend-${{ github.run_id }}

      # Fallback service names if discovery is needed
      PRODUCT_SVC: product-service
      ORDER_SVC: order-service
      CUSTOMER_SVC: customer-service

      # Public ports
      PROD_PORT: "8001"
      ORD_PORT:  "8002"
      CUST_PORT: "8003"

      # Path suffixes
      PRODUCT_PATH: "/products"
      ORDER_PATH:   "/orders"
      CUSTOMER_PATH: "/customers"

    steps:
      - uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: AKS context
        run: |
          RG="${{ secrets.AKS_RESOURCE_GROUP }}"
          CL="${{ secrets.AKS_CLUSTER }}"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            [ -n "${{ inputs.aks_resource_group }}" ] && RG="${{ inputs.aks_resource_group }}"
            [ -n "${{ inputs.aks_cluster_name }}" ]    && CL="${{ inputs.aks_cluster_name }}"
          fi
          az aks get-credentials --resource-group "$RG" --name "$CL" --overwrite-existing

      - name: Ensure namespace
        run: |
          kubectl get ns "$NS" >/dev/null 2>&1 || kubectl create namespace "$NS"

      - name: Resolve backend endpoints (payload > manual > discovery)
        id: resolve
        shell: bash
        run: |
          set -euo pipefail
          trim_slash () { printf "%s" "${1%/}"; }

          # 1) repository_dispatch payload from Backend CD
          P_IN="${{ github.event.client_payload.product_url || '' }}"
          O_IN="${{ github.event.client_payload.order_url   || '' }}"
          C_IN="${{ github.event.client_payload.customer_url|| '' }}"

          # 2) manual workflow_dispatch overrides
          [ -z "$P_IN" ] && P_IN="${{ inputs.product_url || '' }}"
          [ -z "$O_IN" ] && O_IN="${{ inputs.order_url   || '' }}"
          [ -z "$C_IN" ] && C_IN="${{ inputs.customer_url|| '' }}"

          if [[ -n "$P_IN$O_IN$C_IN" ]]; then
            P_BASE="$(trim_slash "$P_IN")"
            O_BASE="$(trim_slash "$O_IN")"
            C_BASE="$(trim_slash "$C_IN")"
            echo "PRODUCT_URL=${P_BASE}${PRODUCT_PATH}"    >> "$GITHUB_ENV"
            echo "ORDER_URL=${O_BASE}${ORDER_PATH}"        >> "$GITHUB_ENV"
            echo "CUSTOMER_URL=${C_BASE}${CUSTOMER_PATH}"  >> "$GITHUB_ENV"
            echo "Using provided URLs."
            exit 0
          fi

          # 3) fallback discovery across namespaces (only if backends still exist)
          need_ns () { kubectl get svc -A | awk -v n="$1" '$2==n{print $1; found=1} END{exit !found}'; }
          get_ep () { kubectl get svc "$2" -n "$1" -o jsonpath='{.status.loadBalancer.ingress[0].ip}{.status.loadBalancer.ingress[0].hostname}'; }

          P_NS=$(need_ns "${PRODUCT_SVC}") || { echo "::error::${PRODUCT_SVC} not found"; exit 1; }
          O_NS=$(need_ns "${ORDER_SVC}")   || { echo "::error::${ORDER_SVC} not found"; exit 1; }
          C_NS=$(need_ns "${CUSTOMER_SVC}")|| { echo "::error::${CUSTOMER_SVC} not found"; exit 1; }

          for i in $(seq 1 120); do
            P_EP=$(get_ep "$P_NS" "${PRODUCT_SVC}") || true
            O_EP=$(get_ep "$O_NS" "${ORDER_SVC}")   || true
            C_EP=$(get_ep "$C_NS" "${CUSTOMER_SVC}")|| true
            [[ -n "$P_EP" && -n "$O_EP" && -n "$C_EP" ]] && break
            echo "Waiting for backend LB endpoints... attempt $i"
            sleep 5
          done
          [[ -n "$P_EP" && -n "$O_EP" && -n "$C_EP" ]] || { echo "::error::Timed out waiting for endpoints"; exit 1; }

          echo "PRODUCT_URL=http://${P_EP}:${PROD_PORT}${PRODUCT_PATH}"     >> "$GITHUB_ENV"
          echo "ORDER_URL=http://${O_EP}:${ORD_PORT}${ORDER_PATH}"          >> "$GITHUB_ENV"
          echo "CUSTOMER_URL=http://${C_EP}:${CUST_PORT}${CUSTOMER_PATH}"   >> "$GITHUB_ENV"

          echo "::notice::Product API:  $(grep '^PRODUCT_URL=' "$GITHUB_ENV" | cut -d= -f2-)"
          echo "::notice::Order API:    $(grep '^ORDER_URL=' "$GITHUB_ENV"   | cut -d= -f2-)"
          echo "::notice::Customer API: $(grep '^CUSTOMER_URL=' "$GITHUB_ENV"| cut -d= -f2-)"

      - name: Inject API URLs into frontend
        run: |
          sed -i "s|_PRODUCT_API_URL_|${PRODUCT_URL}|g"   frontend/main.js
          sed -i "s|_ORDER_API_URL_|${ORDER_URL}|g"       frontend/main.js
          sed -i "s|_CUSTOMER_API_URL_|${CUSTOMER_URL}|g" frontend/main.js
          head -n 30 frontend/main.js

      - name: ACR login
        run: |
          REG="${{ secrets.ACR_LOGIN_SERVER }}"
          NAME="${REG##https://}"; NAME="${NAME%%/*}"; NAME="${NAME%%.azurecr.io}"
          az acr login --name "$NAME"

      - name: Build & push image
        run: |
          docker build -t ${{ secrets.ACR_LOGIN_SERVER }}/frontend:latest ./frontend
          docker push ${{ secrets.ACR_LOGIN_SERVER }}/frontend:latest

      - name: Deploy frontend
        run: |
          kubectl apply -n "$NS" -f k8s/frontend.yaml
          kubectl get deploy,svc,pod -n "$NS" -o wide || true

      - name: Wait for frontend LoadBalancer address
        run: |
          for i in $(seq 1 60); do
            FADDR=$(kubectl get svc frontend -n "$NS" -o jsonpath='{.status.loadBalancer.ingress[0].ip}{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)
            [ -n "$FADDR" ] && break
            echo "Waiting for frontend LB address... attempt $i"
            sleep 5
          done
          [ -n "$FADDR" ] || { echo "::error::Frontend address not assigned"; exit 1; }
          echo "::notice:: Frontend URL: http://$FADDR"
