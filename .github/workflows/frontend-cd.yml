name: Stage 3 - Frontend CD - Deploy to Staging

on:
  workflow_run:
    workflows: ["Stage 2 - Backend CD - Deploy to Staging", "Backend CD", "backend-cd"]
    types: [completed]
  workflow_dispatch:
    inputs:
      aks_cluster_name:
        description: "AKS cluster name (manual only)"
        required: false
        default: ""
      aks_resource_group:
        description: "AKS resource group (manual only)"
        required: false
        default: ""
      product_url:
        description: "Override Product API URL (http://X.X.X.X:8001)"
        required: false
        default: ""
      order_url:
        description: "Override Order API URL (http://Y.Y.Y.Y:8002)"
        required: false
        default: ""
      customer_url:
        description: "Override Customer API URL (http://Z.Z.Z.Z:8003)"
        required: false
        default: ""

jobs:
  deploy_frontend:
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') }}
    runs-on: ubuntu-latest

    env:
      NS: sit722-frontend-${{ github.run_id }}
      PRODUCT_SVC: product-service
      ORDER_SVC: order-service
      CUSTOMER_SVC: customer-service
      PROD_PORT: "8001"
      ORD_PORT: "8002"
      CUST_PORT: "8003"

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: AKS context
        run: |
          RG="${{ secrets.AKS_RESOURCE_GROUP }}"
          CL="${{ secrets.AKS_CLUSTER }}"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            [ -n "${{ inputs.aks_resource_group }}" ] && RG="${{ inputs.aks_resource_group }}"
            [ -n "${{ inputs.aks_cluster_name }}" ]    && CL="${{ inputs.aks_cluster_name }}"
          fi
          az aks get-credentials --resource-group "$RG" --name "$CL" --overwrite-existing

      - name: Ensure namespace
        run: |
          kubectl get ns "$NS" >/dev/null 2>&1 || kubectl create namespace "$NS"

      - name: Resolve backend IPs
        id: ips
        shell: bash
        run: |
          set -euo pipefail

          need_svc () {
            local name="$1"
            if ! kubectl get svc -A | awk -v n="$name" '$2==n{found=1} END{exit !found}'; then
              echo "::error::Service $name not found in any namespace"; exit 1
            fi
            local typ ns
            typ=$(kubectl get svc -A | awk -v n="$name" '$2==n{print $4; exit}')
            ns=$(kubectl get svc -A | awk -v n="$name" '$2==n{print $1; exit}')
            if [[ "$typ" != "LoadBalancer" ]]; then
              echo "::error::Service $name is not LoadBalancer (is $typ)"; exit 1
            fi
            echo "$ns"
          }

          P_NS=$(need_svc "${PRODUCT_SVC}")
          O_NS=$(need_svc "${ORDER_SVC}")
          C_NS=$(need_svc "${CUSTOMER_SVC}")

          get_lb_endpoint () {
            local ns="$1" svc="$2"
            kubectl get svc "$svc" -n "$ns" -o jsonpath='{.status.loadBalancer.ingress[0].ip}{.status.loadBalancer.ingress[0].hostname}'
          }

          for i in $(seq 1 120); do
            P_EP=$(get_lb_endpoint "$P_NS" "${PRODUCT_SVC}") || true
            O_EP=$(get_lb_endpoint "$O_NS" "${ORDER_SVC}")   || true
            C_EP=$(get_lb_endpoint "$C_NS" "${CUSTOMER_SVC}")|| true
            if [[ -n "${P_EP}" && -n "${O_EP}" && -n "${C_EP}" ]]; then
              break
            fi
            echo "Waiting for backend LoadBalancer endpoints... attempt $i"
            sleep 5
          done

          if [[ -z "${P_EP:-}" || -z "${O_EP:-}" || -z "${C_EP:-}" ]]; then
            echo "::error::Timed out waiting for LoadBalancer endpoints"; exit 1
          fi

          echo "PRODUCT_URL=http://${P_EP}:${PROD_PORT}/products"   >> $GITHUB_ENV
          echo "ORDER_URL=http://${O_EP}:${ORD_PORT}/orders"        >> $GITHUB_ENV
          echo "CUSTOMER_URL=http://${C_EP}:${CUST_PORT}/customers" >> $GITHUB_ENV

          echo "::notice:: Product API: http://${P_EP}:${PROD_PORT}/products"
          echo "::notice:: Order API:   http://${O_EP}:${ORD_PORT}/orders"
          echo "::notice:: Customer API:http://${C_EP}:${CUST_PORT}/customers"

      - name: Inject API URLs into main.js
        run: |
          sed -i "s|_PRODUCT_API_URL_|${PRODUCT_URL}|g"   frontend/main.js
          sed -i "s|_ORDER_API_URL_|${ORDER_URL}|g"       frontend/main.js
          sed -i "s|_CUSTOMER_API_URL_|${CUSTOMER_URL}|g" frontend/main.js
          head -n 30 frontend/main.js

      - name: ACR login
        run: |
          REG="${{ secrets.ACR_LOGIN_SERVER }}"
          NAME="${REG##https://}"; NAME="${NAME%%/*}"; NAME="${NAME%%.azurecr.io}"
          az acr login --name "$NAME"

      - name: Build & push image
        run: |
          docker build -t ${{ secrets.ACR_LOGIN_SERVER }}/frontend:latest ./frontend
          docker push ${{ secrets.ACR_LOGIN_SERVER }}/frontend:latest

      - name: Deploy frontend
        run: |
          kubectl apply -n "$NS" -f k8s/frontend.yaml
          kubectl get deploy,svc,pod -n "$NS" -o wide || true

      - name: Wait for frontend LoadBalancer IP
        run: |
          for i in $(seq 1 60); do
            FIP=$(kubectl get svc frontend -n "$NS" -o jsonpath='{.status.loadBalancer.ingress[0].ip}{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)
            [ -n "$FIP" ] && break
            echo "Waiting for frontend LB IP... attempt $i"
            sleep 5
          done
          [ -n "$FIP" ] || { echo "::error::Frontend IP not assigned"; exit 1; }
          echo "::notice:: Frontend URL: http://$FIP"
