name: Stage 3 - Frontend CD - Deploy to Staging

on:
  repository_dispatch:
    types: [backend_cd_succeeded]
  workflow_dispatch:
    inputs:
      aks_cluster_name:
        required: false
        default: ""
      aks_resource_group:
        required: false
        default: ""
      product_url:
        required: false
        default: ""
      order_url:
        required: false
        default: ""
      customer_url:
        required: false
        default: ""

jobs:
  deploy_frontend:
    runs-on: ubuntu-latest
    env:
      # frontend namespace (unique per run)
      NS: sit722-frontend-${{ github.run_id }}

      # fallback service names for discovery (if payload/manual not provided)
      PRODUCT_SVC: product-service
      ORDER_SVC: order-service
      CUSTOMER_SVC: customer-service

      PROD_PORT: "8001"
      ORD_PORT:  "8002"
      CUST_PORT: "8003"

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: AKS context
        run: |
          RG="${{ secrets.AKS_RESOURCE_GROUP }}"
          CL="${{ secrets.AKS_CLUSTER }}"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            [ -n "${{ inputs.aks_resource_group }}" ] && RG="${{ inputs.aks_resource_group }}"
            [ -n "${{ inputs.aks_cluster_name }}" ]    && CL="${{ inputs.aks_cluster_name }}"
          fi
          az aks get-credentials --resource-group "$RG" --name "$CL" --overwrite-existing

      - name: Ensure namespace
        run: |
          kubectl get ns "$NS" >/dev/null 2>&1 || kubectl create namespace "$NS"

      - name: Resolve backend endpoints and set quoted URLs
        id: resolve
        shell: bash
        run: |
          set -euo pipefail

          trim_slash () { printf "%s" "${1%/}"; }

          # 1) Prefer repository_dispatch payload (backend CD sends product_url/order_url/customer_url)
          P_IN="${{ github.event.client_payload.product_url || '' }}"
          O_IN="${{ github.event.client_payload.order_url   || '' }}"
          C_IN="${{ github.event.client_payload.customer_url|| '' }}"

          # 2) Allow manual workflow_dispatch overrides
          [ -z "$P_IN" ] && P_IN="${{ inputs.product_url || '' }}"
          [ -z "$O_IN" ] && O_IN="${{ inputs.order_url   || '' }}"
          [ -z "$C_IN" ] && C_IN="${{ inputs.customer_url|| '' }}"

          if [[ -n "$P_IN$O_IN$C_IN" ]]; then
            # inject exact roots, quoted so main.js receives "http://X.X.X.X:8001"
            P_Q=$(trim_slash "$P_IN")
            O_Q=$(trim_slash "$O_IN")
            C_Q=$(trim_slash "$C_IN")
            echo "PRODUCT_URL=\"${P_Q}\""   >> "$GITHUB_ENV"
            echo "ORDER_URL=\"${O_Q}\""     >> "$GITHUB_ENV"
            echo "CUSTOMER_URL=\"${C_Q}\""  >> "$GITHUB_ENV"
            echo "::notice::Using provided URLs (quoted): ${P_Q} ${O_Q} ${C_Q}"
            exit 0
          fi

          # 3) Fallback discovery across namespaces (only if backends still exist)
          need_ns () { kubectl get svc -A | awk -v n="$1" '$2==n{print $1; exit}'; }
          get_ep () { kubectl get svc "$2" -n "$1" -o jsonpath='{.status.loadBalancer.ingress[0].ip}{.status.loadBalancer.ingress[0].hostname}'; }

          P_NS=$(need_ns "${PRODUCT_SVC}") || { echo "::error::${PRODUCT_SVC} not found"; exit 1; }
          O_NS=$(need_ns "${ORDER_SVC}")   || { echo "::error::${ORDER_SVC} not found"; exit 1; }
          C_NS=$(need_ns "${CUSTOMER_SVC}")|| { echo "::error::${CUSTOMER_SVC} not found"; exit 1; }

          P_EP=""; O_EP=""; C_EP=""
          for i in $(seq 1 120); do
            P_EP=$(get_ep "$P_NS" "${PRODUCT_SVC}") || true
            O_EP=$(get_ep "$O_NS" "${ORDER_SVC}")   || true
            C_EP=$(get_ep "$C_NS" "${CUSTOMER_SVC}")|| true
            if [[ -n "$P_EP" && -n "$O_EP" && -n "$C_EP" ]]; then break; fi
            echo "Waiting for backend LB endpoints... attempt $i"
            sleep 5
          done

          if [[ -z "$P_EP" || -z "$O_EP" || -z "$C_EP" ]]; then
            echo "::error::Timed out waiting for LoadBalancer endpoints"
            kubectl get svc -A -o wide || true
            exit 1
          fi

          # build root URLs and store quoted values in GITHUB_ENV
          echo "PRODUCT_URL=\"http://${P_EP}:${PROD_PORT}\""   >> "$GITHUB_ENV"
          echo "ORDER_URL=\"http://${O_EP}:${ORD_PORT}\""       >> "$GITHUB_ENV"
          echo "CUSTOMER_URL=\"http://${C_EP}:${CUST_PORT}\""   >> "$GITHUB_ENV"

          echo "::notice::Resolved (quoted) Product=${PRODUCT_URL:-}"
          echo "::notice::Resolved (quoted) Order=${ORDER_URL:-}"
          echo "::notice::Resolved (quoted) Customer=${CUSTOMER_URL:-}"

      - name: Inject API URLs into frontend/main.js
        run: |
          # Replace placeholders in main.js with quoted root URLs.
          # main.js must contain placeholders: _PRODUCT_API_URL_ _ORDER_API_URL_ _CUSTOMER_API_URL_
          sed -i "s|_PRODUCT_API_URL_|${PRODUCT_URL}|g"   frontend/main.js
          sed -i "s|_ORDER_API_URL_|${ORDER_URL}|g"       frontend/main.js
          sed -i "s|_CUSTOMER_API_URL_|${CUSTOMER_URL}|g" frontend/main.js

          echo "--- main.js preview (first 30 lines) ---"
          head -n 30 frontend/main.js

      - name: ACR login
        run: |
          REG="${{ secrets.ACR_LOGIN_SERVER }}"
          NAME="${REG##https://}"; NAME="${NAME%%/*}"; NAME="${NAME%%.azurecr.io}"
          az acr login --name "$NAME"

      - name: Build & push image
        run: |
          docker build -t ${{ secrets.ACR_LOGIN_SERVER }}/frontend:latest ./frontend
          docker push ${{ secrets.ACR_LOGIN_SERVER }}/frontend:latest

      - name: Deploy frontend
        run: |
          kubectl apply -n "$NS" -f k8s/frontend.yaml
          kubectl get deploy,svc,pod -n "$NS" -o wide || true

      - name: Wait for frontend LoadBalancer address
        run: |
          for i in $(seq 1 60); do
            FADDR=$(kubectl get svc frontend -n "$NS" -o jsonpath='{.status.loadBalancer.ingress[0].ip}{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)
            [ -n "$FADDR" ] && break
            echo "Waiting for frontend LB address... attempt $i"
            sleep 5
          done
          [ -n "$FADDR" ] || { echo "::error::Frontend address not assigned"; exit 1; }
          echo "::notice:: Frontend URL: http://$FADDR"
